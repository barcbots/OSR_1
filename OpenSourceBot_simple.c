#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    LineFollowA,    sensorLineFollower)
#pragma config(Sensor, in2,    LineFollowB,    sensorLineFollower)
#pragma config(Sensor, in3,    LineFollowC,    sensorLineFollower)
#pragma config(Sensor, in4,    GyroInput,      sensorGyro)
#pragma config(Sensor, in8,    CurrentMonitor, sensorAnalog)
#pragma config(Sensor, dgtl1,  RearSonar,      sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  EStop,          sensorDigitalIn)
#pragma config(Sensor, dgtl4,  EncIntakeIndex, sensorDigitalIn)
#pragma config(Sensor, dgtl5,  EncIntake,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  ArmRLimitHigh,  sensorDigitalIn)
#pragma config(Sensor, dgtl8,  ArmRLimitLow,   sensorDigitalIn)
#pragma config(Sensor, dgtl9,  ArmRLimitLed,   sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, led1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, led2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, led3,           sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  EncLF,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  EncLB,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  EncRB,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  EncRF,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  EncArmR,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,  MotorArmL,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,  MotorLF,        tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port3,  MotorLB,        tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port4,  MotorIL,        tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,  MotorIR,        tmotorVex393, openLoop, encoder, encoderPort, dgtl5, 0)
#pragma config(Motor,  port8,  MotorRB,        tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port9,  MotorRF,        tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port10, MotorArmR,      tmotorVex393, openLoop, encoder, encoderPort, I2C_5, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*                        Copyright (c) James Pearman                          */
/*                                   2013                                      */
/*                            All Rights Reserved                              */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    Module:     OpenSourceBot_simple.c                                       */
/*    Author:     James Pearman                                                */
/*    Created:    31 March 2013                                                */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    This file is part of OSR_1 (open source robot 1)                         */
/*                                                                             */
/*    The author is supplying this software for use with the VEX cortex        */
/*    control system. This file can be freely distributed and teams are        */
/*    authorized to freely use this program , however, it is requested that    */
/*    improvements or additions be shared with the Vex community via the vex   */
/*    forum.  Please acknowledge the work of the authors when appropriate.     */
/*    Thanks.                                                                  */
/*                                                                             */
/*    Licensed under the Apache License, Version 2.0 (the "License");          */
/*    you may not use this file except in compliance with the License.         */
/*    You may obtain a copy of the License at                                  */
/*                                                                             */
/*      http://www.apache.org/licenses/LICENSE-2.0                             */
/*                                                                             */
/*    Unless required by applicable law or agreed to in writing, software      */
/*    distributed under the License is distributed on an "AS IS" BASIS,        */
/*    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. */
/*    See the License for the specific language governing permissions and      */
/*    limitations under the License.                                           */
/*                                                                             */
/*    The author can be contacted on the vex forums as jpearman                */
/*    or electronic mail at jbpearman_at_mac_dot_com                           */
/*    Mentor for team 8888 RoboLancers, Pasadena CA.                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    This is the simplified version of the open source robot control code.    */
/*    Intake and arm are not synchronized, there are no presets and no gyro    */
/*    operation.                                                               */
/*-----------------------------------------------------------------------------*/

#include "Libraries\SmartMotorLib.c"
#include "Libraries\PidLib.c"
#include "OpenSourceBot_lcd.c"

pidController *arm_pid;
pidController *intake_pid;

/*-----------------------------------------------------------------------------*/
/*  estop task                                                                 */
/*  Hit the bumper switch to kill all motors and stop all tasks                */
/*-----------------------------------------------------------------------------*/

task eStopTask()
{
    int  i;
    while(1)
        {
        if( SensorValue[ EStop ] == 0 )
            {
            // Stop all tasks except main and this one
            if( 1 != eStopTask )
                StopTask(1);
            if( 2 != eStopTask )
	            StopTask(2);
            if( 3 != eStopTask )
	            StopTask(3);
            if( 4 != eStopTask )
	            StopTask(4);
            if( 5 != eStopTask )
	            StopTask(5);
            if( 6 != eStopTask )
	            StopTask(6);
            if( 7 != eStopTask )
	            StopTask(7);
            if( 8 != eStopTask )
	            StopTask(8);
            if( 9 != eStopTask )
	            StopTask(9);
            if( 10 != eStopTask )
	            StopTask(10);
            if( 11 != eStopTask )
	            StopTask(11);
            if( 12 != eStopTask )
	            StopTask(12);
            if( 13 != eStopTask )
	            StopTask(13);
            if( 14 != eStopTask )
	            StopTask(14);
            if( 15 != eStopTask )
	            StopTask(15);

            for(i=0;i<10;i++)
                motor[i] = 0;
            }

            wait1Msec(10);
        }
}


/*-----------------------------------------------------------------------------*/
/*  Drive control task                                                         */
/*                                                                             */
/*  Uses joystick Ch3, Ch4 and Btn8L, Btn8R                                    */
/*-----------------------------------------------------------------------------*/

void
DriveSystemMecanumDrive( )
{
    short   forward, turn, right;

    long drive_l_front;
    long drive_l_back;
    long drive_r_front;
    long drive_r_back;

    // Get controller
    if( abs( vexRT[ Ch3 ] ) > 10 )
        forward = vexRT[ Ch3 ];
    else
        forward = 0;

    if( abs( vexRT[ Ch4 ] ) > 10 )
        right   = vexRT[ Ch4 ];
    else
        right = 0;

    if( vexRT[ Btn8R ] == 1 )
        turn = 64;
    else
    if( vexRT[ Btn8L ] == 1 )
        turn = -64;
    else
        turn = 0;

    // Set drive
    drive_l_front = forward + turn + right;
    drive_l_back  = forward + turn - right;

    drive_r_front = forward - turn - right;
    drive_r_back  = forward - turn + right;

    // normalize drive so max is 127 if any drive is over 127
    int max = abs(drive_l_front);
    if (abs(drive_l_back)  > max)
        max = abs(drive_l_back);
    if (abs(drive_r_back)  > max)
        max = abs(drive_r_back);
    if (abs(drive_r_front) > max)
        max = abs(drive_r_front);
    if (max>127) {
        drive_l_front = 127 * drive_l_front / max;
        drive_l_back  = 127 * drive_l_back  / max;
        drive_r_back  = 127 * drive_r_back  / max;
        drive_r_front = 127 * drive_r_front / max;
    }

    // Send to motors
    // left drive
    SetMotor( MotorLF, drive_l_front);
    SetMotor( MotorLB, drive_l_back);

    // right drive
    SetMotor( MotorRF, drive_r_front);
    SetMotor( MotorRB, drive_r_back);
}

/*-----------------------------------------------------------------------------*/
/*  Drive control task                                                         */
/*-----------------------------------------------------------------------------*/

task
DriveTask()
{
    while(1)
        {
        DriveSystemMecanumDrive();
        wait1Msec(25);
        }
}

/*-----------------------------------------------------------------------------*/
/*  Check the hard limit switches and kill power if triggered                  */
/*-----------------------------------------------------------------------------*/

void
ArmSystemCheckHardLimits()
{
    static  int hardStopL = 0;
    static  int hardStopH = 0;

    // Check low limit switch
    if( SensorValue[ ArmRLimitLow ] == 0 )
        {
        if( arm_pid->drive_cmd < 0 )
            {
            arm_pid->drive_cmd = 0;
            // hard stop
            if( !hardStopL )
                {
                hardStopL = 1;

                // hard stop
                SetMotor( MotorArmL, 20, true);
                SetMotor( MotorArmR, 20, true);
                wait1Msec(100);
                SetMotor( MotorArmL, 0, true);
                SetMotor( MotorArmR, 0, true);

                // zero encoder
                SensorValue[ EncArmR ] = 0;
                }
            }
        }
    else
        hardStopL = 0;

    if( SensorValue[ ArmRLimitHigh ] == 0 )
        {
        if( arm_pid->drive_cmd > 0 )
            {
            arm_pid->drive_cmd = 0;
            if( !hardStopH )
                {
                hardStopH = 1;

                // hard stop
                SetMotor( MotorArmL, -20, true);
                SetMotor( MotorArmR, -20, true);
                wait1Msec(100);
                SetMotor( MotorArmL, 0, true);
                SetMotor( MotorArmR, 0, true);
                }
            }
        }
    else
        hardStopH = 0;
}

/*-----------------------------------------------------------------------------*/
/*  PID control of the arm                                                     */
/*-----------------------------------------------------------------------------*/

void
ArmSystemDoArmControl( )
{
    // get controller
    if( vexRT[ Btn8U ] == 1 )
        arm_pid->target_value = arm_pid->target_value + 20;
    else
    if( vexRT[ Btn8D ] == 1 )
        arm_pid->target_value = arm_pid->target_value - 25;

    // If the intake is rotated we need to wait until it is in the
    // correct position to allow the arm to be lowered.
    if( arm_pid->target_value < 400 )
        {
        if( abs(intake_pid->sensor_value) > 45 )
            arm_pid->target_value = 400;
        }

    // clip
    if( arm_pid->target_value < 0 )
        arm_pid->target_value = 0;
    if( arm_pid->target_value > 1500 )
        arm_pid->target_value = 1500;

    // pid control
    PidControllerUpdate( arm_pid );

    // Kill if power is lost
    if( nImmediateBatteryLevel < 3000 )
        arm_pid->drive_cmd = 0;

    // check limit switches
    ArmSystemCheckHardLimits();

    // send to motors
    SetMotor( MotorArmL, arm_pid->drive_cmd);
    SetMotor( MotorArmR, arm_pid->drive_cmd);
}

/*-----------------------------------------------------------------------------*/
/*  PID control of the intake                                                  */
/*-----------------------------------------------------------------------------*/

void
ArmSystemDoIntakeControl( )
{
    // get controller
    if( vexRT[ Btn6U ] == 1 )
        intake_pid->target_value = intake_pid->target_value - 5;
    else
    if( vexRT[ Btn6D ] == 1 )
        intake_pid->target_value = intake_pid->target_value + 5;

    // limit intake to 180 degrees (quad encoder has 360 ticks per rev)
    if( abs(intake_pid->target_value) > 180 )
        intake_pid->target_value = sgn( intake_pid->target_value ) * 180;

    // No operation if arm is low
    if( arm_pid->target_value < 500 )
        intake_pid->target_value = 0;

    // pid control
    PidControllerUpdate( intake_pid );

    // Kill if power is lost
    if( nImmediateBatteryLevel < 3000 )
        intake_pid->drive_cmd = 0;

    // send to motors
    SetMotor( MotorIL, intake_pid->drive_cmd);
    SetMotor( MotorIR, intake_pid->drive_cmd );
}

/*-----------------------------------------------------------------------------*/
/*  Arm control task                                                           */
/*-----------------------------------------------------------------------------*/

task
ArmTask()
{
    // Init - no bias
    arm_pid = PidControllerInit( 0.004, 0.0, 0.01, EncArmR, 0 );
    intake_pid = PidControllerInit( 0.02, 0.00, 0.05, EncIntake, 0 );
    SensorValue[EncArmR]   = 0;
    SensorValue[EncIntake] = 0;

    while(1)
        {
        // control the arm
        ArmSystemDoArmControl();
        // control the scoop
        ArmSystemDoIntakeControl();
        wait1Msec(25);
        }
}


task main()
{
    // start estop task
    StartTask( eStopTask, 10 );

    // Init the smart motor library
    SmartMotorsInit();
    SmartMotorCurrentMonitorEnable();
    SmartMotorSetControllerStatusLed( SMLIB_CORTEX_PORT_0, led2 );
    SmartMotorSetControllerStatusLed( SMLIB_CORTEX_PORT_1, led3 );

    SmartMotorLinkMotors( MotorArmR, MotorArmL );

    SmartMotorsSetEncoderGearing( MotorIR, 0.33333333 );
    SmartMotorLinkMotors( MotorIR, MotorIL );

    SmartMotorRun();

    // control tasks
    StartTask( DriveTask );
    StartTask( ArmTask );

    // Init LCD
    bLCDBacklight = true;
    clearLCDLine(0);
    clearLCDLine(1);

    // loop  and display status
    while(1)
        {
        LcdDisplayStatus();

        wait1Msec(25);
        }
}
