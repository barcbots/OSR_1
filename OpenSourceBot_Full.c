#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    LineFollowA,    sensorLineFollower)
#pragma config(Sensor, in2,    LineFollowB,    sensorLineFollower)
#pragma config(Sensor, in3,    LineFollowC,    sensorLineFollower)
#pragma config(Sensor, in4,    GyroInput,      sensorGyro)
#pragma config(Sensor, in8,    CurrentMonitor, sensorAnalog)
#pragma config(Sensor, dgtl1,  RearSonar,      sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  EStop,          sensorDigitalIn)
#pragma config(Sensor, dgtl4,  EncIntakeIndex, sensorDigitalIn)
#pragma config(Sensor, dgtl5,  EncIntake,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  ArmRLimitHigh,  sensorDigitalIn)
#pragma config(Sensor, dgtl8,  ArmRLimitLow,   sensorDigitalIn)
#pragma config(Sensor, dgtl9,  ArmRLimitLed,   sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, led1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, led2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, led3,           sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  EncLF,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  EncLB,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  EncRB,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  EncRF,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  EncArmR,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,  MotorArmL,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,  MotorLF,       tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port3,  MotorLB,       tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port4,  MotorIL,       tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,  MotorIR,       tmotorVex393, openLoop, encoder, encoderPort, dgtl5, 0)
#pragma config(Motor,  port8,  MotorRB,       tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port9,  MotorRF,       tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port10, MotorArmR,     tmotorVex393, openLoop, encoder, encoderPort, I2C_5, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*                        Copyright (c) James Pearman                          */
/*                                   2013                                      */
/*                            All Rights Reserved                              */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    Module:     OpenSourceBot_full.c                                         */
/*    Author:     James Pearman                                                */
/*    Created:    31 March 2013                                                */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    This file is part of OSR_1 (open source robot 1)                         */
/*                                                                             */
/*    The author is supplying this software for use with the VEX cortex        */
/*    control system. This file can be freely distributed and teams are        */
/*    authorized to freely use this program , however, it is requested that    */
/*    improvements or additions be shared with the Vex community via the vex   */
/*    forum.  Please acknowledge the work of the authors when appropriate.     */
/*    Thanks.                                                                  */
/*                                                                             */
/*    Licensed under the Apache License, Version 2.0 (the "License");          */
/*    you may not use this file except in compliance with the License.         */
/*    You may obtain a copy of the License at                                  */
/*                                                                             */
/*      http://www.apache.org/licenses/LICENSE-2.0                             */
/*                                                                             */
/*    Unless required by applicable law or agreed to in writing, software      */
/*    distributed under the License is distributed on an "AS IS" BASIS,        */
/*    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. */
/*    See the License for the specific language governing permissions and      */
/*    limitations under the License.                                           */
/*                                                                             */
/*    The author can be contacted on the vex forums as jpearman                */
/*    or electronic mail at jbpearman_at_mac_dot_com                           */
/*    Mentor for team 8888 RoboLancers, Pasadena CA.                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    This is the full version of the open source robot control code.          */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

#include "Libraries\SmartMotorLib.c"
#include "Libraries\GyroLib.c"
#include "Libraries\DriveLib.c"
#include "Libraries\PidLib.c"
#include "Libraries\PstLib.c"

#include "OpenSourceBot_lcd2.c"
#include "OpenSourceBot_Arm.c"
#include "OpenSourceBot_Intake.c"

/*-----------------------------------------------------------------------------*/
/*  estop task                                                                 */
/*  Hit the bumper switch to kill all motors and stop all tasks                */
/*-----------------------------------------------------------------------------*/

task eStopTask()
{
    int  i;
    while(1)
        {
        if( SensorValue[ EStop ] == 0 )
            {
            // Stop all tasks except main and this one
            if( 1 != eStopTask )
                StopTask(1);
            if( 2 != eStopTask )
	            StopTask(2);
            if( 3 != eStopTask )
	            StopTask(3);
            if( 4 != eStopTask )
	            StopTask(4);
            if( 5 != eStopTask )
	            StopTask(5);
            if( 6 != eStopTask )
	            StopTask(6);
            if( 7 != eStopTask )
	            StopTask(7);
            if( 8 != eStopTask )
	            StopTask(8);
            if( 9 != eStopTask )
	            StopTask(9);
            if( 10 != eStopTask )
	            StopTask(10);
            if( 11 != eStopTask )
	            StopTask(11);
            if( 12 != eStopTask )
	            StopTask(12);
            if( 13 != eStopTask )
	            StopTask(13);
            if( 14 != eStopTask )
	            StopTask(14);
            if( 15 != eStopTask )
	            StopTask(15);

            for(i=0;i<10;i++)
                motor[i] = 0;
            }

            wait1Msec(10);
        }
}

/*-----------------------------------------------------------------------------*/
/*  Monitor arm lower limit switch and reset encoder on first trigger          */
/*-----------------------------------------------------------------------------*/

task ArmEncoderReset()
{
    short  reset = 0;

    while(1)
        {
        if( SensorValue[ ArmRLimitLow ] == 0 )
            {
            if(!reset)
                {
                SensorValue[ EncArmR ] = 0;
                reset = 1;
                }
            SensorValue[ ArmRLimitLed ] = 1;
            }
        else
            {
            if( SensorValue[ ArmRLimitHigh ] == 0 )
                SensorValue[ ArmRLimitLed ] = 1;
            else
                SensorValue[ ArmRLimitLed ] = 0;
            }

            wait1Msec(25);
        }
}

/*-----------------------------------------------------------------------------*/
/*  Unfold intake, triggered from the LCD currently                            */
/*-----------------------------------------------------------------------------*/

void
IntakeSystemUnfold()
{
    ArmSystemAutonSetArmPosition(1);
    ArmSystemWaitInPosition();
    PlayImmediateTone(1000, 30);

    IntakeSystemCalibrate();
    PlayImmediateTone(1500, 30);

    ArmSystemAutonSetArmPosition(0);
    ArmSystemWaitInPosition();
    PlayImmediateTone(1000, 30);
}

/*-----------------------------------------------------------------------------*/

task main()
{
    // start estop task
    StartTask(eStopTask);

    // Init the speed and current functions
    SmartMotorsInit();
    SmartMotorCurrentMonitorEnable();
    SmartMotorSetControllerStatusLed( SMLIB_CORTEX_PORT_0, led2 );
    SmartMotorSetControllerStatusLed( SMLIB_CORTEX_PORT_1, led3 );

    // Gyro init
    GyroInit( GyroInput );

    // Run smart motors
    SmartMotorRun();

    // Drive System
    DriveSystemInit( Mecanum4Motor, MotorLF, MotorLB, MotorRF, MotorRB );
    DriveSystemAttachControls( Ch3, Ch4,  Btn8R, Btn8L );
    DriveSystemSetChannelScale( 2, 0.3 );
    DriveSystemRun();

    // Arm system
    ArmSystemInit( EncArmR, MotorArmR, MotorArmL );
    ArmSystemSetLimits( 0, 3350 );
    ArmSystemSetLimitSwitches( ArmRLimitLow, ArmRLimitHigh );
    ArmSystemAddPresetPositions(    0 );
    ArmSystemAddPresetPositions(  200 );
    ArmSystemAddPresetPositions( 1000 );
    ArmSystemAddPresetPositions( 2500 );
    ArmSystemAttachControls( Ch2, Btn8U, Btn8D, Btn7U, Btn7L );
    ArmSystemAttachEnableButton( Btn6U, 0 );
    SmartMotorLinkMotors( MotorArmR, MotorArmL );

    // Intake system
    IntakeSystemInit( EncIntake, EncIntakeIndex, MotorIR, MotorIL );
    IntakeSystemAddPresetOffset( -20 );
    IntakeSystemAddPresetOffset( 0 );
    IntakeSystemAddPresetOffset( 20 );
    IntakeSystemAttachControls( Ch2, Btn5U, Btn5D );
    IntakeSystemAttachEnableButton( Btn6U, 1, 0x01 );
    SmartMotorsSetEncoderGearing( MotorIR, 0.33333333 );
    SmartMotorLinkMotors( MotorIR, MotorIL );

    // start the arm and intake systems
    ArmSystemRun();
    IntakeSystemRun();

    // Monitor lower limit switch to reset Arm encoder
    StartTask( ArmEncoderReset );

    // Init LCD
    bLCDBacklight = true;
    clearLCDLine(0);
    clearLCDLine(1);

    // loop  and display status
    while(1)
        {
        LcdDisplayStatus();

        wait1Msec(100);
        }
}
